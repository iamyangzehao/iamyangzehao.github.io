{"meta":{"title":"iamyzh","subtitle":"今日事, 今日毕","description":"技术小站","author":"iamyzh","url":"https://iamyangzehao.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-31T09:05:49.668Z","updated":"2020-05-31T09:05:49.668Z","comments":true,"path":"404.html","permalink":"https://iamyangzehao.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-05-31T01:40:05.000Z","updated":"2020-05-31T09:00:28.256Z","comments":true,"path":"about/index.html","permalink":"https://iamyangzehao.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2020-05-31T09:04:55.005Z","updated":"2020-05-31T09:04:55.005Z","comments":true,"path":"friends/index.html","permalink":"https://iamyangzehao.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2020-05-24T13:00:44.000Z","updated":"2020-05-31T09:01:32.506Z","comments":true,"path":"categories/index.html","permalink":"https://iamyangzehao.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-31T09:04:15.669Z","updated":"2020-05-31T09:04:15.669Z","comments":true,"path":"mylist/index.html","permalink":"https://iamyangzehao.github.io/mylist/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-31T02:02:03.000Z","updated":"2020-05-31T02:02:21.400Z","comments":true,"path":"contact/index.html","permalink":"https://iamyangzehao.github.io/contact/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-31T01:23:47.000Z","updated":"2020-05-31T09:02:07.417Z","comments":true,"path":"tags/index.html","permalink":"https://iamyangzehao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WebMvcConfigurer接口详解","slug":"SpringBoot/WebMvcConfigurer接口详解","date":"2020-08-23T03:35:50.000Z","updated":"2020-08-23T03:43:55.817Z","comments":true,"path":"2020/08/23/springboot/webmvcconfigurer-jie-kou-xiang-jie/","link":"","permalink":"https://iamyangzehao.github.io/2020/08/23/springboot/webmvcconfigurer-jie-kou-xiang-jie/","excerpt":"SpringBoot确实为我们做了很多事情, 但有时候我们想要自己定义一些Handler、Interceptor、ViewResolver、MessageConverter时该怎么做呢？在SpringBoot 1.5版本都是靠重写WebMvcConfigurerAdapter的方法来添加自定义拦截器，消息转换器等。SpringBoot2.0后, 该类被标记为@Deprecated。因此我们只能靠实现WebMvcConfigurer接口来实现。接下来让我们看看这个接口类吧!","text":"SpringBoot确实为我们做了很多事情, 但有时候我们想要自己定义一些Handler、Interceptor、ViewResolver、MessageConverter时该怎么做呢？在SpringBoot 1.5版本都是靠重写WebMvcConfigurerAdapter的方法来添加自定义拦截器，消息转换器等。SpringBoot2.0后, 该类被标记为@Deprecated。因此我们只能靠实现WebMvcConfigurer接口来实现。接下来让我们看看这个接口类吧!","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://iamyangzehao.github.io/categories/SpringBoot/"},{"name":"SpringMVC","slug":"SpringBoot/SpringMVC","permalink":"https://iamyangzehao.github.io/categories/SpringBoot/SpringMVC/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://iamyangzehao.github.io/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://iamyangzehao.github.io/tags/SpringMVC/"}]},{"title":"virtualbox桥接模式下如何实现静态IP访问内外网","slug":"Linux/virtualbox桥接模式下如何实现静态IP访问内外网","date":"2020-07-18T23:41:06.000Z","updated":"2020-07-19T00:48:30.151Z","comments":true,"path":"2020/07/19/linux/virtualbox-qiao-jie-mo-shi-xia-ru-he-shi-xian-jing-tai-ip-fang-wen-nei-wai-wang/","link":"","permalink":"https://iamyangzehao.github.io/2020/07/19/linux/virtualbox-qiao-jie-mo-shi-xia-ru-he-shi-xian-jing-tai-ip-fang-wen-nei-wai-wang/","excerpt":"之前想要设置静态IP, 是因为设置了桥接网卡, 导致有时使用Xshell连接CentOS时IP发生了变化, 不得不查看IP重新连接, 所以想要设置静态IP, 解决连接问题, 一劳永逸.","text":"之前想要设置静态IP, 是因为设置了桥接网卡, 导致有时使用Xshell连接CentOS时IP发生了变化, 不得不查看IP重新连接, 所以想要设置静态IP, 解决连接问题, 一劳永逸. 首先, 在virtualbox中配置网卡, 选择桥接网卡模式 正常启动虚拟机, 通过 ip addr命令, 查看当前虚拟机的IP地址 修改网卡配置文件. vi /etc/sysconfig/network-scripts/ifcfg-enp0s3命令(我的网卡配置文件就是ifcfg-enp0s3文件) 将第四行的BOOTPROTO=&quot;dhcp&quot;改为BOOTPROTO=&quot;static&quot;,最后一行改成ONBOOT=&quot;yes&quot; 查询物理主机的网卡信息, 通过ipconfig命令, 确认需要的IPv4地址、子网掩码、默认网关等信息 IPv4 地址 . . . . . . . . . . . . : 192.168.155.4 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.155.1 修改ifcfg-enp0s3配置文件, 实现内网外互通(PS:在配置文件最低行添加以下代码) IPADDR=192.168.155.x --- x可为2-255的任意数字, 这里我设置x为12 NETMASK=255.255.255.0 GATEWAY=192.168.155.1 DNS1=114.114.114.114 修改完成后保存退出, 使用systemctl start network.service或service network restart重启网卡服务 验证结果: 以下验证步骤全部成功说明设置完成 先进入虚拟机钟查询修改后的ip是否为设置的静态ip(命令: ip addr) 检查主机与虚拟机的互通性(在主机上ping虚拟机的ip, 然后在虚拟机上ping主机的ip) 检查虚拟机是否能连接网络(ping www.baidu.com)","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://iamyangzehao.github.io/categories/CentOS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://iamyangzehao.github.io/tags/Linux/"}]},{"title":"ASM入门","slug":"JVM/ASM入门","date":"2020-07-11T08:32:47.000Z","updated":"2020-07-18T23:40:54.915Z","comments":true,"path":"2020/07/11/jvm/asm-ru-men/","link":"","permalink":"https://iamyangzehao.github.io/2020/07/11/jvm/asm-ru-men/","excerpt":"ASM概述 ASM 是一个Java字节码操纵框架, 它能被用来动态生成类或者增强既有类的功能。 ASM可以直接产生二进制Class文件, 也可以在类被加载入虚拟机之前动态改变类的行为, ASM从类文件中读入信息后, 能够改变类行为、分析类信息, 甚至能根据要求生成新类。 目前许多框架如cglib、Hibernate、Spring都直接或者间接地使用ASM操作字节码。","text":"ASM概述 ASM 是一个Java字节码操纵框架, 它能被用来动态生成类或者增强既有类的功能。 ASM可以直接产生二进制Class文件, 也可以在类被加载入虚拟机之前动态改变类的行为, ASM从类文件中读入信息后, 能够改变类行为、分析类信息, 甚至能根据要求生成新类。 目前许多框架如cglib、Hibernate、Spring都直接或者间接地使用ASM操作字节码。 ASM编程模型 ==Core API==: 提供了基于事件形式的编程模型。该模型不需要一次性地将整个类的结构读取到内存中，因此这种方式更快，需要更少的内存。但这种编程形式难度更大。 ==Tree API==: 提供了基于树形的编程模型。该模型需要一次性将一个类的完整结构全部读取到内存当中。所以这种方法需要更多的内存。这种编程方式比较简单。 ASM的Core API-1 ASM Core API中操纵字节码的功能基于ClassVisitor 接口。这个接口中的每个方法对应了Class文件中的每一项。 ASM提供了三个基于ClassVisitor接口的类来实现Class文件的生成和转换。 ClassReader：ClassReader解析一个类的Class字节码。 ClassAdapter：ClassAdapter是ClassVisitor的实现类，实现要变化的功能。 ClassWriter：ClassWriter也是ClassVisitor的实现类，可以用来输出变化后的字节码。 ASM给我们提供了ASMifier工具来帮助开发，可使用ASMifier工具生成ASM结构来对比。","categories":[{"name":"JDK","slug":"JDK","permalink":"https://iamyangzehao.github.io/categories/JDK/"},{"name":"JVM","slug":"JDK/JVM","permalink":"https://iamyangzehao.github.io/categories/JDK/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://iamyangzehao.github.io/tags/JVM/"},{"name":"ASM","slug":"ASM","permalink":"https://iamyangzehao.github.io/tags/ASM/"}]},{"title":"Jenkins配置主题","slug":"Jenkins/Jenkins配置主题","date":"2020-06-25T02:43:53.000Z","updated":"2020-06-25T14:17:41.143Z","comments":true,"path":"2020/06/25/jenkins/jenkins-pei-zhi-zhu-ti/","link":"","permalink":"https://iamyangzehao.github.io/2020/06/25/jenkins/jenkins-pei-zhi-zhu-ti/","excerpt":"Jenkins默认的主题实在是太丑了,所以简单配置了一下主题, 现在舒服多了","text":"Jenkins默认的主题实在是太丑了,所以简单配置了一下主题, 现在舒服多了 Jenkins主题的配置步骤: 首先进入配置Jenkins主题的网站: http://afonsof.com/jenkins-material-theme/ 选择你喜欢的颜色，这里我选teal, 2. 然后上传logo，logo最好是透明背景的，要不然会很丑. 3.下载主题 将该主题上传到服务器中。因为我是用docker安装Jenkins的，然后Jenkins指向的实际目录是/home/jenkins_home,，所以进入 /home/jenkins_home下的useContent目录，然后新建layout目录，然后上传该主题到layout目录下 进入Jenkins管理界面, 点击Manage Jenkins，然后点击Manage Plugins，在可选插件项的搜索框中搜索Simple Theme并安装，安装成功后点击Manage Jenkins，然后点击Configure System，找到Theme一栏，新增CSS URL，填入主题所在位置的路径(http://192.168.155.4:9090/userContent/layout/主题名称.css PS：192.168.155.4:9090是访问Jenkins的路径，主题名称填具体的主题名称) 保存 具体参考： https://blog.csdn.net/DynastyRumble/article/details/103910441 Jenkins的登录账号密码账号: admin密码: wsyzhstbms /** https://jenkins-zh.cn/ */","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://iamyangzehao.github.io/tags/Jenkins/"}]},{"title":"CentOS安装Kafka","slug":"Kafka/CentOS安装Kafka","date":"2020-06-21T15:17:42.000Z","updated":"2020-06-23T15:46:57.497Z","comments":true,"path":"2020/06/21/kafka/centos-an-zhuang-kafka/","link":"","permalink":"https://iamyangzehao.github.io/2020/06/21/kafka/centos-an-zhuang-kafka/","excerpt":"最近刚开始学习Kafka，第一步肯定是学会怎么安装Kafka，现在我来讲解一下","text":"最近刚开始学习Kafka，第一步肯定是学会怎么安装Kafka，现在我来讲解一下 第一步：安装JDK。安装JDK的步骤比较简单，这里可以直接在网上找教程学习怎么安装第二步：安装Zookeeper。除了安装JDK，还需要安装Zookeeper,安装和启动Zookeeper的步骤参考CentOS安装ZooKeeper第三步： 安装Kafka。安装Kafka分为: 先下载Kafka并解压出来 修改config/server.properties文件, 主要修改listeners、advertised.listeners配置(将host.name修改成kafka安装的主机的ip)和log.dirs(主要存放kafka的日志，可以在kafka根目录下创建一个logs文件夹，并将log.dirs设置成该文件夹的路径)和zookeeper.connect（设置连接的Zookeeper所在主机的ip，如果kafka和Zookeeper在同一台机器上，该配置不用改，默认为localhost） 最后，在kafka的根目录下，执行bin/kafka-server-start.sh config/server.properties &amp; 命令，让kafka以后台方式启动 注意事项:kafka启动时，报cannot allocate memory错误，即内存不足，因为学生机内存较小，1G，所以需要更改kafka启动时的内存，解决方法: 进入bin目录，修改kafka-server-start.sh文件，将export KAFKA_HEAP_OPTS=”-Xmx1G -Xms1G”改成export KAFKA_HEAP_OPTS=”-Xmx256M -Xms128M” ，改小点，确保能启动 Kafka的基本命令: bin/kafka-server-stop.sh – 停止Kafka bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test-topic 创建名为test-topic的Topic，localhost可更换为zookeeper所在的机器的ip bin/kafka-topics.sh –list –zookeeper localhost:2181 – 查看已经创建的Topic信息 bin/kafka-console-producer.sh –broker-list localhost:9092 –topic test-topic – 发送消息 bin/kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic test-topic –from-beginning – 接收消息 如何安装Kafka图形界面工具Kafka-Center? 网址: https://github.com/xaecbd/KafkaCenter 到github上下载table_script.sql和application.properties，并上传到服务器中(我传到了/usr/local/workspace/projects/gitproject/others目录中) 将table_script.sql导入到数据库中 修改application.properties配置文件，注意主要修改数据库地址和ElasticSearch地址(ES没有的话可不改) 进入到/usr/local/workspace/projects/gitproject/others目录中，执行docker run -d -p 8240:8240 –name KafkaCenter -v ${PWD}/application.properties:/opt/app/kafka-center/config/application.properties xaecbd/kafka-center:2.1.0 命令 在安全组中开放8240端口号(因为在上一步中指定了Kafka-Center的端口号为8240，不放开该端口号就无法访问) 访问http://ip:8240，我的机器的ip是129.204.22.23， 所以通过http://129.204.22.23:8240/访问，访问账号密码是admin/admin","categories":[],"tags":[]},{"title":"MySQL对于千万级的大表要怎么优化?","slug":"MySQL/MySQL对于千万级的大表要怎么优化","date":"2020-06-14T01:36:29.000Z","updated":"2020-06-14T02:37:27.243Z","comments":true,"path":"2020/06/14/mysql/mysql-dui-yu-qian-wan-ji-de-da-biao-yao-zen-me-you-hua/","link":"","permalink":"https://iamyangzehao.github.io/2020/06/14/mysql/mysql-dui-yu-qian-wan-ji-de-da-biao-yao-zen-me-you-hua/","excerpt":"首先采用MySQL存储千亿级别的数据，确实是一项非常大的挑战。MySQL单表确实可以存储10亿级的数据，只是这个时候性能非常差，项目钟大量的实验证明，MySQL单表容量在500万左右，性能处于最佳状态。","text":"首先采用MySQL存储千亿级别的数据，确实是一项非常大的挑战。MySQL单表确实可以存储10亿级的数据，只是这个时候性能非常差，项目钟大量的实验证明，MySQL单表容量在500万左右，性能处于最佳状态。 针对大表的优化，主要是通过数据库分库分表来解决，目前比较普遍的方案有三个：分区、分库分表、NoSQL/NewSQL。实际项目中，这三种方案是结合的，目前绝大部分系统的核心数据都是以RDBMS存储为主，NoSQL/NewSQL存储为辅。 分区首先来了解一下分区方案。分区表是由多个相关的底层表实现的。这些底层表也是由句柄对象表示，所以我们可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样(所有的底层表都必须使用相同的存储引擎)，分区表的索引只是在各个底层表上各自加上一个相同的索引。这个方案对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作(只是这个时候性能一般)。 不过它的缺点很明显:很多的资源都受到单机的限制，例如连接数、网络吞吐等。如何进行分区，在实际应用中是一个非常关键的要素之一。 下面开始举例: 以客户信息为例，客户数据量5000万+，项目背景要求保存客户的银行卡绑定关系，客户的证件绑定关系，以及客户绑定的业务信息。 此业务背景下，如何设计数据库呢？项目一期的时候，我们建立了一张客户业务绑定关系表，里面冗余了每一位客户绑定的业务信息。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://iamyangzehao.github.io/categories/MySQL/"}],"tags":[{"name":"分库分表","slug":"分库分表","permalink":"https://iamyangzehao.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"性能优化","slug":"性能优化","permalink":"https://iamyangzehao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"nacos_gateway","slug":"谷粒商城项目方档/nacos-gateway","date":"2020-06-13T15:17:34.000Z","updated":"2020-06-13T15:22:18.412Z","comments":true,"path":"2020/06/13/gu-li-shang-cheng-xiang-mu-fang-dang/nacos-gateway/","link":"","permalink":"https://iamyangzehao.github.io/2020/06/13/gu-li-shang-cheng-xiang-mu-fang-dang/nacos-gateway/","excerpt":"谷粒商城项目文档第一篇: nacos&amp;&amp;gateway","text":"谷粒商城项目文档第一篇: nacos&amp;&amp;gateway 1. Nacos概述官方地址：https://nacos.io github地址：https://github.com/alibaba/nacos 面试题：微服务间远程交互的过程？ 先去注册中心查询服务的服务器地址 调用方给对方发送http请求 1.1. 什么是 NacosNacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 1.2. 为什么是Nacos常见的注册中心： Eureka（原生，2.0遇到性能瓶颈，停止维护） Zookeeper（支持，专业的独立产品。例如：dubbo） Consul（原生，GO语言开发） Nacos 相对于 Spring Cloud Eureka 来说，Nacos 更强大。 Nacos = Spring Cloud Eureka + Spring Cloud Config Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。 1.3. 可以干什么Nacos是以服务为主要服务对象的中间件，Nacos支持所有主流的服务发现、配置和管理。 Nacos主要提供以下四大功能： 服务发现和服务健康监测 动态配置服务 动态DNS服务 服务及其元数据管理 2. Nacos快速开始结构图： Nacos 依赖 Java 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 Maven环境，请确保是在以下版本环境中安装使用: 64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。 64 bit JDK 1.8+ Maven 3.2.x+ 2.1. 下载及安装你可以通过源码和发行包两种方式来获取 Nacos。 从 Github 上下载源码方式 git clone https://github.com/alibaba/nacos.git cd nacos/ # 切换到nacos根目录，执行下列命令 mvn -Prelease-nacos clean install -U # 要下载很多依赖 会比较慢 ls -al distribution/target/ # 切换目录 # change the $version to your actual path cd distribution/target/nacos-server-$version/nacos/bin 下载源码压缩包方式 您可以从 最新稳定版本 下载 nacos-server-$version.zip 包。 unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz cd nacos/bin 2.2. 启动nacos服务Linux/Unix/Mac 启动命令(standalone代表着单机模式运行，非集群模式): sh startup.sh -m standaloneWindows 启动命令： cmd startup.cmd或者双击startup.cmd运行文件。 访问：http://localhost:8848/nacos 用户名密码：nacos/nacos 2.3. 注册中心首先创建两个工程：nacos-provider、nacos-consumer 创建生产者： 创建消费者： 然后，一路下一步或者ok。效果如下： 2.3.1. 生产者基本代码 ProviderController代码如下： @RestController public class ProviderController { @Value(\"${myName}\") private String name; @GetMapping(\"hello\") public String hello(){ return \"hello \" + name; } } application.properties配置如下： server.port=8070 # 自定义参数 myName=nacos 2.3.2. 生产者注册到nacos生产者注册到nacos注册中心，步骤： 添加依赖：spring-cloud-starter-alibaba-nacos-discovery及springCloud &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;!-- SpringCloud的依赖 --> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>Greenwich.SR2&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> 注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。 在 application.properties 中配置nacos服务地址和应用名 server.port=8070 spring.application.name=nacos-provider # nacos服务地址 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 # 自定义参数 myName=nacos 通过Spring Cloud原生注解 @EnableDiscoveryClient 开启服务注册发现功能 @SpringBootApplication @EnableDiscoveryClient public class NacosProviderApplication { public static void main(String[] args) { SpringApplication.run(NacosProviderApplication.class, args); } } 效果： 2.3.3. 消费端基本代码 ConsumerController代码： @RestController public class ConsumerController { @GetMapping(\"hi\") public String hi() { return \"hi provider!\"; } } application.properties: server.port=8080 2.3.4. 消费者注册到nacos消费者注册到nacos跟生产者差不多，也分3步： 添加依赖：同生产者 在application.properties中配置nacos的服务名及服务地址：同生产者 在引导类（NacosConsumerApplication.java）中添加@EnableDiscoveryClient注解：同生产者 效果： 2.3.5. 使用feign调用服务 以前我们使用feign来远程调用，这里也一样。引入feign的依赖： &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;!-- SpringCloud的依赖 --> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>Greenwich.SR2&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> 在NacosConsumerApplication类上添加@EnableFeignClients注解： @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class NacosConsumerApplication { public static void main(String[] args) { SpringApplication.run(NacosConsumerApplication.class, args); } } 编写feignClient： @FeignClient(\"nacos-provider\") public interface ProviderFeign { @RequestMapping(\"hello\") public String hello(); } 在Controller中使用feignClient： @RestController public class ConsumerController { @Autowired private ProviderFeign providerFeign; @GetMapping(\"hi\") public String hi() { return this.providerFeign.hello(); } } 测试访问： 2.4. 配置中心​ 在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。 如果微服务架构中没有使用统一配置中心时，所存在的问题： 配置文件分散在各个项目里，不方便维护 配置内容安全与权限 更新配置后，项目需要重启 nacos配置中心：系统配置的集中管理（编辑、存储、分发）、动态更新不重启、回滚配置（变更管理、历史版本管理、变更审计）等所有与配置相关的活动。 案例：改造生产者中的动态配置项，由配置中心统一管理。 2.4.1. nacos中创建统一配置 dataId 的完整格式如下： ${prefix}-${spring.profile.active}.${file-extension} prefix 默认为所属工程配置spring.application.name 的值（即：nacos-provider），也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 总结：配置所属工程的spring.application.name的值 + “.” + properties/yml 配置内容： 项目中易变的内容。例如：myName 当前案例中，nacos-provider工程的spring.application.name=nacos-provider，没有配置spring.profiles.active。所以这里的dataId填写的是nacos-provider.properties 2.4.2. 从配置中心读取配置从配置中心读取配置，分以下3步： 引入依赖 在生产者中引入依赖： &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;/dependency> 注意：版本 0.2.x.RELEASE 对应的是 Spring Boot 2.x 版本，版本 0.1.x.RELEASE 对应的是 Spring Boot 1.x 版本。 在 bootstrap.properties 中配置 Nacos server 的地址和应用名 spring.cloud.nacos.config.server-addr=127.0.0.1:8848 # 该配置影响统一配置中心中的dataId，之前已经配置过 spring.application.name=nacos-provider 说明：之所以需要配置 spring.application.name ，是因为它是构成 Nacos 配置管理 dataId字段的一部分。 在springboot工程中，bootstrap.properties的加载优先级更高。 通过 Spring Cloud 原生注解 @RefreshScope 实现配置自动更新： @RestController @RefreshScope public class ProviderController { @Value(\"${myName}\") private String name; @RequestMapping(\"hello\") public String hello(){ return \"hello \" + name; } } 2.4.3. 名称空间切换环境在实际开发中，通常有多套不同的环境（默认只有public），那么这个时候可以根据指定的环境来创建不同的 namespce，例如，开发、测试和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。以此来实现多环境的隔离。 切换到配置列表： 可以发现有四个名称空间：public（默认）以及我们自己添加的3个名称空间（prod、dev、test），可以点击查看每个名称空间下的配置文件，当然现在只有public下有一个配置。 默认情况下，项目会到public下找 服务名.properties文件。 接下来，在dev名称空间中也添加一个nacos-provider.properties配置。这时有两种方式： 切换到dev名称空间，添加一个新的配置文件。缺点：每个环境都要重复配置类似的项目 直接通过clone方式添加配置，并修改即可。推荐 点击编辑：修改配置内容，以作区分 在服务提供方nacos-provider中切换命名空间，修改bootstrap.properties添加如下配置 spring.cloud.nacos.config.namespace=7fd7e137-21c4-4723-a042-d527149e63e0 namespace的值为： 重启服务提供方服务，在浏览器中访问测试： 2.4.4. 回滚配置（了解）目前版本该功能有bug，回滚之后配置消失。 回滚配置只需要两步： 查看历史版本 回滚到某个历史版本 2.4.5. 加载多配置文件偶尔情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：nacos-provider.properties、redis.properties、jdbc.properties。 nacos-provider.properties默认加载，怎么加载另外两个配置文件？ 在bootstrap.properties文件中添加如下配置： spring.cloud.nacos.config.ext-config[0].data-id=redis.properties # 开启动态刷新配置，否则配置文件修改，工程无法感知 spring.cloud.nacos.config.ext-config[0].refresh=true spring.cloud.nacos.config.ext-config[1].data-id=jdbc.properties spring.cloud.nacos.config.ext-config[1].refresh=true 修改ProviderController使用redis.properties和jdbc.properties配置文件中的参数： @RestController @RefreshScope public class ProviderController { @Value(\"${myName}\") private String name; @Value(\"${jdbc.url}\") private String jdbcUrl; @Value(\"${redis.url}\") private String redisUrl; @RequestMapping(\"hello\") public String hello(){ return \"hello \" + name + \", redis-url=\" + redisUrl + \", jdbc-url=\" + jdbcUrl; } } 测试效果： 问题： ​ 修改一下配置中心中redis.properties中的配置，不重启服务。能否加载配置信息 ​ 删掉spring.cloud.nacos.config.ext-config[0].refresh=true，再修改redis.properties中的配置试试 2.4.6. 配置的分组在实际开发中，除了不同的环境外。不同的微服务或者业务功能，可能有不同的redis及mysql数据库。 区分不同的环境我们使用名称空间（namespace），区分不同的微服务或功能，使用分组（group）。 当然，你也可以反过来使用，名称空间和分组只是为了更好的区分配置，提供的两个维度而已。 新增一个redis.properties，所属分组为provider： 现在开发环境中有两个redis.propertis配置文件，一个是默认分组（DEFAULT_GROUP），一个是provider组 默认情况下从DEFAULT_GROUP分组中读取redis.properties，如果要切换到provider分组下的redis.properties，需要添加如下配置： # 指定分组 spring.cloud.nacos.config.ext-config[0].group=provider 缺点： ​ 将来每个分组下会有太多的配置文件，不利于维护。 最佳实践： ​ 命名空间区分业务功能，分组区分环境。 3. 服务网关GatewayAPI 网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题： 破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性，典型的架构图如图所示： 3.1. 快速开始创建网关module： 完成后： 3.1.1. 引入依赖已引入，如下。pom.xml中的依赖： &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>${spring-cloud.version}&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> 3.1.2. 编写路由规则为了演示路由到不同服务，这里把消费者和生产者都配置在网关中 application.yml server: port: 8090 spring: cloud: gateway: routes: - id: nacos-consumer uri: http://127.0.0.1:8080 predicates: - Path=/hi - id: nacos-provider uri: http://127.0.0.1:8070 predicates: - Path=/hello 3.1.3. 启动测试通过网关路径访问消费者或者生产者。 3.2. 路由规则详解 基本概念： Route：路由网关的基本构建块。它由ID，目的URI，断言（Predicate）集合和过滤器（filter）集合组成。如果断言聚合为真，则匹配该路由。 Predicate：这是一个 Java 8函数式断言。允许开发人员匹配来自HTTP请求的任何内容，例如请求头或参数。 过滤器：可以在发送下游请求之前或之后修改请求和响应。 路由根据断言进行匹配，匹配成功就会转发请求给URI，在转发请求之前或者之后可以添加过滤器。 3.2.1. 断言工厂Spring Cloud Gateway包含许多内置的Route Predicate工厂。所有这些断言都匹配HTTP请求的不同属性。多路由断言工厂通过and组合。 官方提供的路由工厂： 这些断言工厂的配置方式，参照官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html 这里重点掌握请求路径路由断言的配置方式： spring: cloud: gateway: routes: - id: host_route uri: http://example.org predicates: - Path=/foo/{segment},/bar/{segment} 这个路由匹配以/foo或者/bar开头的路径，转发到http:example.org。例如 /foo/1 or /foo/bar or /bar/baz. 3.2.2. 过滤器工厂路由过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。路径过滤器的范围限定为特定路由。Spring Cloud Gateway包含许多内置的GatewayFilter工厂。 这些过滤器工厂的配置方式，同样参照官方文档：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html 过滤器 有 20 多个 实现类,根据过滤器工厂的用途来划分，可以分为以下几种：Header、Parameter、Path、Body、Status、Session、Redirect、Retry、RateLimiter和Hystrix 这里重点掌握PrefixPath GatewayFilter Factory 上面的配置中，所有的/foo/**开始的路径都会命中配置的router，并执行过滤器的逻辑，在本案例中配置了RewritePath过滤器工厂，此工厂将/foo/(?.*)重写为{segment}，然后转发到http://example.org。比如在网页上请求localhost:8090/foo/forezp，此时会将请求转发到http://example.org/forezp的页面 ​ 在开发中由于所有微服务的访问都要经过网关，为了区分不同的微服务，通常会在路径前加上一个标识，例如：访问服务提供方：http://localhost:8090/provider/hello ；访问服务消费方：http://localhost:8090/consumer/hi 如果不重写地址，直接转发的话，转发后的路径为：http://localhost:8070/provider/hello和http://localhost:8080/consumer/hi明显多了一个provider或者consumer，导致转发失败。 这时，我们就用上了路径重写，配置如下： server: port: 8090 spring: cloud: gateway: routes: - id: nacos-consumer uri: http://127.0.0.1:8080 predicates: - Path=/consumer/** filters: - RewritePath=/consumer/(?&lt;segment>.*),/$\\{segment} - id: nacos-provider uri: http://127.0.0.1:8070 predicates: - Path=/provider/** filters: - RewritePath=/provider/(?&lt;segment>.*),/$\\{segment} 注意：Path=/consumer/**及Path=/provider/**的变化 测试： 3.3. 面向服务的路由 如果要做到负载均衡，则必须把网关工程注册到nacos注册中心，然后通过服务名访问。 3.3.1. 把网关服务注册到nacos 引入nacos的相关依赖： &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-config&lt;/artifactId> &lt;version>0.2.2.RELEASE&lt;/version> &lt;/dependency> 配置nacos服务地址及服务名： bootstrap.yml中的配置： spring: application: name: gateway-demo cloud: nacos: config: server-addr: 127.0.0.1:8848 application.yml中的配置： server: port: 8090 spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: routes: - id: nacos-consumer uri: http://127.0.0.1:8080 predicates: - Path=/consumer/** filters: - RewritePath=/consumer/(?&lt;segment>.*),/$\\{segment} - id: nacos-provider uri: http://127.0.0.1:8070 predicates: - Path=/provider/** filters: - RewritePath=/provider/(?&lt;segment>.*),/$\\{segment} 把网关注入到nacos @SpringBootApplication @EnableDiscoveryClient public class GatewayDemoApplication { public static void main(String[] args) { SpringApplication.run(GatewayDemoApplication.class, args); } } 3.3.2. 修改配置，通过服务名路由server: port: 8090 spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 gateway: routes: - id: nacos-consumer uri: lb://nacos-consumer predicates: - Path=/consumer/** filters: - RewritePath=/consumer/(?&lt;segment>.*),/$\\{segment} - id: nacos-provider uri: lb://nacos-provider predicates: - Path=/provider/** filters: - RewritePath=/provider/(?&lt;segment>.*),/$\\{segment} 语法：lb://服务名 lb：LoadBalance，代表负载均衡的方式 服务名取决于nacos的服务列表中的服务名 3.4. 路由的java代码配置方式（了解）参见官方文档： 代码如下： @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) { return builder.routes() .route(r -&gt; r.host(&quot;**.abc.org&quot;).and().path(&quot;/image/png&quot;) .filters(f -&gt; f.addResponseHeader(&quot;X-TestHeader&quot;, &quot;foobar&quot;)) .uri(&quot;http://httpbin.org:80&quot;) ) .route(r -&gt; r.path(&quot;/image/webp&quot;) .filters(f -&gt; f.addResponseHeader(&quot;X-AnotherHeader&quot;, &quot;baz&quot;)) .uri(&quot;http://httpbin.org:80&quot;) ) .route(r -&gt; r.order(-1) .host(&quot;**.throttle.org&quot;).and().path(&quot;/get&quot;) .filters(f -&gt; f.filter(throttle.apply(1, 1, 10, TimeUnit.SECONDS))) .uri(&quot;http://httpbin.org:80&quot;) ) .build(); }","categories":[{"name":"nacos","slug":"nacos","permalink":"https://iamyangzehao.github.io/categories/nacos/"},{"name":"gateway","slug":"nacos/gateway","permalink":"https://iamyangzehao.github.io/categories/nacos/gateway/"}],"tags":[{"name":"项目文档","slug":"项目文档","permalink":"https://iamyangzehao.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"}]},{"title":"Java并发--Thread&&Runnable详细讲解","slug":"并发编程/Java并发-Thread-Runnable详细讲解","date":"2020-05-31T13:08:47.000Z","updated":"2020-06-06T08:34:17.276Z","comments":true,"path":"2020/05/31/bing-fa-bian-cheng/java-bing-fa-thread-runnable-xiang-xi-jiang-jie/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/31/bing-fa-bian-cheng/java-bing-fa-thread-runnable-xiang-xi-jiang-jie/","excerpt":"关于Thread和Runnable的一些理解","text":"关于Thread和Runnable的一些理解","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://iamyangzehao.github.io/categories/Java%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"Java并发/多线程","permalink":"https://iamyangzehao.github.io/categories/Java%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"https://iamyangzehao.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"test5","slug":"测试文档/test5","date":"2020-05-31T07:57:54.000Z","updated":"2020-05-31T09:21:40.807Z","comments":true,"path":"2020/05/31/ce-shi-wen-dang/test5/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/31/ce-shi-wen-dang/test5/","excerpt":"如果标题居中且下方不想显示任何 meta 信息，可以这样设置：","text":"如果标题居中且下方不想显示任何 meta 信息，可以这样设置：","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"test4","slug":"测试文档/test4","date":"2020-05-31T07:57:45.000Z","updated":"2020-05-31T09:16:56.015Z","comments":true,"path":"2020/05/31/ce-shi-wen-dang/test4/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/31/ce-shi-wen-dang/test4/","excerpt":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id","text":"标题右边显示迷你音乐播放器，支持的字段有：server、type、id","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"test3","slug":"测试文档/test3","date":"2020-05-31T07:57:35.000Z","updated":"2020-05-31T09:16:08.712Z","comments":true,"path":"2020/05/31/ce-shi-wen-dang/test3/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/31/ce-shi-wen-dang/test3/","excerpt":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者：","text":"由于支持多作者共同维护一个博客，所以可以设置单独一篇文章的作者：","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"}],"author":{"name":"作者","avatar":"https://img.vim-cn.com/a1/d53c11fb5d4fd69529bc805d385fe818feb3f6.png","url":"https://baidu.com"}},{"title":"test2","slug":"测试文档/test2","date":"2020-05-31T07:57:28.000Z","updated":"2020-05-31T09:14:44.014Z","comments":true,"path":"2020/05/31/ce-shi-wen-dang/test2/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/31/ce-shi-wen-dang/test2/","excerpt":"这是摘要","text":"这是摘要 这是正文 注意： &lt;!-- more --&gt;前后一定要有空行，不然可能导致显示错位。","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"test1","slug":"测试文档/test1","date":"2020-05-31T07:56:12.000Z","updated":"2020-06-13T15:22:42.155Z","comments":true,"path":"2020/05/31/ce-shi-wen-dang/test1/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/31/ce-shi-wen-dang/test1/","excerpt":"这是摘要","text":"这是摘要 一、摸不清世间的方向，看不清未来的道路，与其在黑暗中摸索匍匐前进，不如学会静得其心。以“静”的姿态铸就人性的优雅；以“静”的淡然锤炼心的明镜；以“静”的倩影折射出世间的温暖。二、走出一段路程，回头一望，也是生动着、美丽着；有着你爱的人和爱你的人，有着你喜欢的事和需要你做的事，有着牵挂你的人和你牵挂着的人；人这一辈子是短暂的，所以要让自己幸福着。三、一个人的美丽，并不是容颜，而是所有经历过的往事、在心中留下伤痕褪去，令人坚强而安谧。所以，优雅不是训练出来的，而是一种阅历。淡然不是伪装出来的，而是一种沉淀。四、不恋尘世浮华，不写红尘纷扰，不叹世道苍凉，不惹情思哀怨，闲看花开，静待花落。","categories":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"测试A","slug":"测试/测试A","permalink":"https://iamyangzehao.github.io/categories/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95A/"}],"tags":[{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"https://iamyangzehao.github.io/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]},{"title":"JDK体系结构","slug":"JVM/JDK体系结构","date":"2020-05-24T09:57:59.000Z","updated":"2020-05-31T13:13:20.797Z","comments":true,"path":"2020/05/24/jvm/jdk-ti-xi-jie-gou/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/24/jvm/jdk-ti-xi-jie-gou/","excerpt":"这是摘要","text":"这是摘要 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 主题配置修改到 Next主题进阶优化配置 部分了Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment Deploy to remote sites","categories":[{"name":"Java","slug":"Java","permalink":"https://iamyangzehao.github.io/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://iamyangzehao.github.io/categories/Java/JDK/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://iamyangzehao.github.io/tags/JVM/"}]},{"title":"Hello World","slug":"测试文档/hello-world","date":"2020-05-02T23:45:13.441Z","updated":"2020-05-31T09:25:18.852Z","comments":true,"path":"2020/05/03/ce-shi-wen-dang/hello-world/","link":"","permalink":"https://iamyangzehao.github.io/2020/05/03/ce-shi-wen-dang/hello-world/","excerpt":"meta 区域显示外链按钮 这是摘要","text":"meta 区域显示外链按钮 这是摘要 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 主题配置修改到 Next主题进阶优化配置 部分了Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"渲染公式（MathJax）","slug":"测试文档/example-md","date":"2020-02-22T16:00:00.000Z","updated":"2020-05-31T09:50:01.080Z","comments":true,"path":"2020/02/23/ce-shi-wen-dang/example-md/","link":"","permalink":"https://iamyangzehao.github.io/2020/02/23/ce-shi-wen-dang/example-md/","excerpt":"more：","text":"more： $$t+1=2$$ $$\\mbox{积累因子}=\\begin{cases}1+ni &amp; \\mbox{单利}\\\\(1+i)^n &amp; \\mbox{复利}\\end{cases}$$ $$\\begin{equation}\\sum_{i=0}^n F_i \\cdot \\phi (H, p_i) - \\sum_{i=1}^n a_i \\cdot ( \\tilde{x_i}, \\tilde{y_i}) + b_i \\cdot ( \\tilde{x_i}^2 , \\tilde{y_i}^2 )\\end{equation}$$$$\\begin{equation}\\beta^*(D) = \\mathop{argmin} \\limits_{\\beta} \\lambda {||\\beta||}^2 + \\sum_{i=1}^n max(0, 1 - y_i f_{\\beta}(x_i))\\end{equation}$$","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://iamyangzehao.github.io/categories/SpringBoot/"},{"name":"SpringMVC","slug":"SpringBoot/SpringMVC","permalink":"https://iamyangzehao.github.io/categories/SpringBoot/SpringMVC/"},{"name":"CentOS","slug":"CentOS","permalink":"https://iamyangzehao.github.io/categories/CentOS/"},{"name":"JDK","slug":"JDK","permalink":"https://iamyangzehao.github.io/categories/JDK/"},{"name":"JVM","slug":"JDK/JVM","permalink":"https://iamyangzehao.github.io/categories/JDK/JVM/"},{"name":"MySQL","slug":"MySQL","permalink":"https://iamyangzehao.github.io/categories/MySQL/"},{"name":"nacos","slug":"nacos","permalink":"https://iamyangzehao.github.io/categories/nacos/"},{"name":"gateway","slug":"nacos/gateway","permalink":"https://iamyangzehao.github.io/categories/nacos/gateway/"},{"name":"Java并发","slug":"Java并发","permalink":"https://iamyangzehao.github.io/categories/Java%E5%B9%B6%E5%8F%91/"},{"name":"多线程","slug":"Java并发/多线程","permalink":"https://iamyangzehao.github.io/categories/Java%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/categories/%E6%B5%8B%E8%AF%95/"},{"name":"测试A","slug":"测试/测试A","permalink":"https://iamyangzehao.github.io/categories/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95A/"},{"name":"Java","slug":"Java","permalink":"https://iamyangzehao.github.io/categories/Java/"},{"name":"JDK","slug":"Java/JDK","permalink":"https://iamyangzehao.github.io/categories/Java/JDK/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://iamyangzehao.github.io/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://iamyangzehao.github.io/tags/SpringMVC/"},{"name":"Linux","slug":"Linux","permalink":"https://iamyangzehao.github.io/tags/Linux/"},{"name":"JVM","slug":"JVM","permalink":"https://iamyangzehao.github.io/tags/JVM/"},{"name":"ASM","slug":"ASM","permalink":"https://iamyangzehao.github.io/tags/ASM/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://iamyangzehao.github.io/tags/Jenkins/"},{"name":"分库分表","slug":"分库分表","permalink":"https://iamyangzehao.github.io/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"性能优化","slug":"性能优化","permalink":"https://iamyangzehao.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"项目文档","slug":"项目文档","permalink":"https://iamyangzehao.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"},{"name":"并发编程","slug":"并发编程","permalink":"https://iamyangzehao.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"测试","slug":"测试","permalink":"https://iamyangzehao.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"毒鸡汤","slug":"毒鸡汤","permalink":"https://iamyangzehao.github.io/tags/%E6%AF%92%E9%B8%A1%E6%B1%A4/"}]}